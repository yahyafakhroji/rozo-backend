# Rozo Backend API - Cursor Rules

## Project Overview

This is a Supabase Edge Functions project for payment processing built with Deno/TypeScript. It uses Privy for wallet authentication.

## Architecture Patterns

### Authentication System

- **Privy Authentication**: All functions (except webhooks) use Privy for authentication
- **Authentication Flow**:
  1. Extract Bearer token from Authorization header
  2. Verify JWT via Privy SDK
  3. Extract `privyId` and `walletAddress` from verified token
  4. Query merchant by `privy_id`

### Database Patterns

- **Merchant Identification**: Query by `privy_id` column
  ```typescript
  .eq("privy_id", privyId)
  ```
- **Schema**: merchants table uses `privy_id` as the primary identifier (required, unique)
- **Migrations**: Located in `supabase/migrations/` with timestamps

### Function Structure

- **All Functions**: Use Hono framework for modern routing and middleware
- **Webhook Function**: payment-callback (no authentication, webhook secret only)
- **Cron Functions**: expired-orders, update-currencies (scheduled jobs)

## Code Conventions

### File Structure

```
supabase/
├── _shared/                    # Shared utilities and middleware
│   ├── config/                # Constants, CORS configuration
│   ├── middleware/            # Auth, error handling, PIN validation
│   ├── services/              # Business logic services
│   ├── utils/                 # Common utility functions
│   ├── types/                 # TypeScript interfaces
│   ├── schemas/               # Zod validation schemas
│   └── factories/             # Transaction factory
├── functions/
│   ├── <function>/
│   │   ├── index.ts   # Main entry point
│   │   └── deno.json  # Deno configuration
```

### Import Patterns

- Use double quotes for strings consistently
- Group imports: external deps, then relative imports
- Use `npm:` prefix for npm packages in Deno

### Error Handling

- Consistent error response structure:
  ```typescript
  c.json({ success: false, error: "Error message" }, 400);
  ```
- Use Hono's built-in error handling middleware

### Authentication Utils Pattern

```typescript
// In jwt.utils.ts
export async function verifyPrivyJWT(
  token: string,
  appId: string,
  appSecret: string
): Promise<AuthResult>;
export function extractBearerToken(authHeader: string | null): string | null;
```

### Database Query Patterns

- Always use parameterized queries
- Use `.single()` for single record operations
- Use `.select()` to specify needed columns
- Apply proper error handling for database operations

### CORS Configuration

Use Hono's CORS middleware:

```typescript
import { cors } from "jsr:@hono/hono/cors";

app.use("*", cors(corsConfig));
```

## Function-Specific Patterns

### Hono Functions (all functions)

```typescript
const app = new Hono().basePath(`/${functionName}`);

// Configure middleware
app.use("*", cors(corsConfig));
app.use("*", errorMiddleware);

// Auth routes use privyAuthMiddleware
app.get("/", privyAuthMiddleware, merchantResolverMiddleware, handleGet);
app.post("/", privyAuthMiddleware, merchantResolverMiddleware, handleCreate);

// Export
Deno.serve(app.fetch);
```

### Middleware Pattern (Hono)

- `privyAuthMiddleware` handles Privy authentication
- Sets context variables: `privyId`, `walletAddress`, `supabase`, `token`
- `merchantResolverMiddleware` caches merchant data in context
- Sets: `merchant`, `merchantId`

## Environment Variables

### Required Variables

```bash
# Supabase
ROZO_SUPABASE_URL=
ROZO_SUPABASE_SERVICE_ROLE_KEY=

# Authentication (Privy)
PRIVY_APP_ID=
PRIVY_APP_SECRET=

# Payments
DAIMO_API_KEY=
ROZO_PAY_URL=

# Notifications
PUSHER_APP_ID=
PUSHER_KEY=
PUSHER_SECRET=
PUSHER_CLUSTER=

# Wallet (Privy)
PRIVY_POLICY_ID=
PRIVY_AUTHORIZATION_PRIVATE_KEY=
```

## Development Workflow

### Code Style

- Always run `deno fmt` before committing
- Use `deno lint` to check for issues
- Follow TypeScript strict mode patterns
- Use proper typing instead of `any`

### Database Operations

- Use transactions for multi-step operations
- Always validate input data with Zod schemas
- Use proper SQL escaping through Supabase client
- Handle both success and error cases

### Testing

- Test with Privy tokens
- Test error cases (invalid tokens, missing data)
- Verify CORS headers in all responses
- Test database queries

## Integration Patterns

### Daimo Pay Integration

```typescript
const paymentResponse = await createDaimoPaymentLink({
  merchant,
  intent: "Order Payment",
  orderNumber: orderNumber,
  amountUnits: formattedUsdAmount.toString(),
  // ... other config
});
```

### Pusher Notifications

```typescript
const notification = await pushNotification(merchantId, eventType, payloadData);
```

### Currency Conversion

```typescript
// Skip conversion for USD
let required_amount_usd = amount;
if (currency !== "USD") {
  const { data: currencyData } = await supabase
    .from("currencies")
    .select("usd_price")
    .eq("currency_id", currency)
    .single();
  required_amount_usd = currencyData.usd_price * amount;
}
```

## Security Patterns

### JWT Verification

- Always verify tokens before processing requests
- Handle expired/invalid tokens gracefully
- Extract user information from verified tokens
- Never trust client-provided user IDs

### Webhook Security

- Verify webhook signatures
- Use proper authentication headers
- Validate payload structure
- Prevent replay attacks

### Database Security

- Use service role key for database operations
- Apply RLS policies where appropriate
- Validate all input parameters
- Use parameterized queries

## Deployment Patterns

### Local Development

```bash
npx supabase start
npx supabase functions serve --env-file .env.local
```

### Production Deployment

```bash
npx supabase functions deploy [function-name]
```

### Environment Management

- Use `.env.local` for local development
- Set environment variables in Supabase dashboard for production
- Never commit secrets to version control

## Common Gotchas

1. **Authentication**: Always use `privyAuthMiddleware` for protected routes
2. **Context Variables**: Access via `c.get("privyId")`, `c.get("merchant")`, etc.
3. **CORS**: Use Hono's cors middleware, not manual headers
4. **Error Handling**: Use `errorMiddleware` for consistent error responses
5. **Pagination**: Implement proper pagination for list endpoints
6. **Status Validation**: Validate status transitions in webhook handlers
7. **Currency Conversion**: Handle USD as special case (no conversion needed)

## Best Practices

1. **Consistency**: Follow established patterns across all functions
2. **Error Handling**: Always provide meaningful error messages
3. **Validation**: Use Zod schemas for all input validation
4. **Logging**: Use console.log for debugging, console.error for errors
5. **Performance**: Use proper indexing and efficient queries
6. **Maintainability**: Keep functions focused and modular
